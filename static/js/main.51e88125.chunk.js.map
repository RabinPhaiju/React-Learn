{"version":3,"sources":["PathfindingVisualizer/Node/Node.js","algorithms/dijkstra.js","PathfindingVisualizer/PathfindingVisualizer.js","App.js","reportWebVitals.js","index.js"],"names":["node","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","row","extraClassName","id","className","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","getInitialGrid","currentRow","createNode","console","log","getNewGridWithWallToggled","newGrid","slice","newNode","PathfindingVisualizer","React","useState","setGrid","mouseIsPressed","setMouseIsPressed","useEffect","animateShortestPath","nodesInShortestPathOrder","i","setTimeout","document","getElementById","visualizeDijkstra","animateDijkstra","currentNode","unshift","getNodesInShortestPathOrder","onClick","map","rowIdx","nodeIdx","handleMouseDown","handleMouseEnter","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.51e88125.chunk.js","sourcesContent":["import React from \"react\";\r\n\r\nimport \"./Node.css\";\r\n\r\nconst node = ({ col, isFinish, isStart, isWall, onMouseDown, onMouseEnter, onMouseUp, row }) => {\r\n  const extraClassName = isFinish\r\n    ? \"node-finish\"\r\n    : isStart\r\n    ? \"node-start\"\r\n    : isWall\r\n    ? \"node-wall\"\r\n    : \"\";\r\n\r\n  return (\r\n    <div\r\n      id={`node-${row}-${col}`}\r\n      className={`node ${extraClassName}`}\r\n      onMouseDown={() => onMouseDown(row, col)}\r\n      onMouseEnter={() => onMouseEnter(row, col)}\r\n      onMouseUp={() => onMouseUp()}\r\n    ></div>\r\n  );\r\n};\r\n\r\nexport default node;\r\n","// Performs Dijkstra's algorithm; returns *all* nodes in the order\r\n// in which they were visited. Also makes nodes point back to their\r\n// previous node, effectively allowing us to compute the shortest path\r\n// by backtracking from the finish node.\r\nexport function dijkstra(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  startNode.distance = 0;\r\n  const unvisitedNodes = getAllNodes(grid);\r\n  while (!!unvisitedNodes.length) {\r\n    sortNodesByDistance(unvisitedNodes);\r\n    const closestNode = unvisitedNodes.shift();\r\n    // If we encounter a wall, we skip it.\r\n    if (closestNode.isWall) continue;\r\n    // If the closest node is at a distance of infinity,\r\n    // we must be trapped and should therefore stop.\r\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n    updateUnvisitedNeighbors(closestNode, grid);\r\n  }\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    neighbor.distance = node.distance + 1;\r\n    neighbor.previousNode = node;\r\n  }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const { col, row } = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\n// Backtracks from the finishNode to find the shortest path.\r\n// Only works when called *after* the dijkstra method above.\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","import React, { useEffect } from \"react\";\r\nimport Node from \"./Node/Node\";\r\nimport { dijkstra, getNodesInShortestPathOrder } from \"../algorithms/dijkstra\";\r\n\r\nimport \"./PathfindingVisualizer.css\";\r\n\r\nconst START_NODE_ROW = 10;\r\nconst START_NODE_COL = 15;\r\nconst FINISH_NODE_ROW = 10;\r\nconst FINISH_NODE_COL = 35;\r\n\r\nconst PathfindingVisualizer = () => {\r\n  const [grid, setGrid] = React.useState([]);\r\n  const [mouseIsPressed, setMouseIsPressed] = React.useState(false);\r\n\r\n  useEffect(() => {\r\n    const grid = getInitialGrid();\r\n    setGrid(grid);\r\n  }, []);\r\n\r\n  const handleMouseDown = (row, col) => {\r\n    const newGrid = getNewGridWithWallToggled(grid, row, col);\r\n    setGrid(newGrid);\r\n    setMouseIsPressed(true);\r\n  };\r\n  const handleMouseEnter = (row, col) => {\r\n    if (!mouseIsPressed) return;\r\n    const newGrid = getNewGridWithWallToggled(grid, row, col);\r\n    setGrid(newGrid);\r\n  };\r\n\r\n  const handleMouseUp = () => {\r\n    setMouseIsPressed(false);\r\n  };\r\n\r\n  const animateDijkstra = (visitedNodesInOrder, nodesInShortestPathOrder) => {\r\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length) {\r\n        setTimeout(() => {\r\n          animateShortestPath(nodesInShortestPathOrder);\r\n        }, 10 * i);\r\n        return;\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-visited\";\r\n      }, 10 * i);\r\n    }\r\n  };\r\n  const animateShortestPath = (nodesInShortestPathOrder) => {\r\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n      setTimeout(() => {\r\n        const node = nodesInShortestPathOrder[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node-shortest-path\";\r\n      }, 50 * i);\r\n    }\r\n  };\r\n\r\n  const visualizeDijkstra = () => {\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n    animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <button className='button' onClick={() => visualizeDijkstra()}>\r\n        Visualize Dijkstra's Algorithm\r\n      </button>\r\n      <div className='grid'>\r\n        {grid.map((row, rowIdx) => {\r\n          return (\r\n            <div key={rowIdx}>\r\n              {row.map((node, nodeIdx) => {\r\n                const { row, col, isFinish, isStart, isWall } = node;\r\n                return (\r\n                  <Node\r\n                    key={nodeIdx}\r\n                    col={col}\r\n                    isFinish={isFinish}\r\n                    isStart={isStart}\r\n                    isWall={isWall}\r\n                    mouseIsPressed={mouseIsPressed}\r\n                    onMouseDown={(row, col) => handleMouseDown(row, col)}\r\n                    onMouseEnter={(row, col) => handleMouseEnter(row, col)}\r\n                    onMouseUp={() => handleMouseUp()}\r\n                    row={row}\r\n                  />\r\n                );\r\n              })}\r\n            </div>\r\n          );\r\n        })}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nconst getInitialGrid = () => {\r\n  const grid = [];\r\n  for (let row = 0; row < 20; row++) {\r\n    const currentRow = [];\r\n    for (let col = 0; col < 50; col++) {\r\n      currentRow.push(createNode(col, row));\r\n      console.log(currentRow);\r\n    }\r\n    grid.push(currentRow);\r\n  }\r\n  return grid;\r\n};\r\nconst createNode = (col, row) => {\r\n  return {\r\n    col,\r\n    row,\r\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\r\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\r\n    distance: Infinity,\r\n    isVisited: false,\r\n    isWall: false,\r\n    previousNode: null,\r\n  };\r\n};\r\nconst getNewGridWithWallToggled = (grid, row, col) => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n  const newNode = {\r\n    ...node,\r\n    isWall: !node.isWall,\r\n  };\r\n  newGrid[row][col] = newNode;\r\n  return newGrid;\r\n};\r\n\r\nexport default PathfindingVisualizer;\r\n","import React from \"react\";\nimport \"./App.css\";\nimport PathfindingVisualizer from \"./PathfindingVisualizer/PathfindingVisualizer\";\n\nfunction App() {\n  return (\n    <div className='App'>\n      <PathfindingVisualizer />\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}